---
layout: material
title: 'Part 2 - Version control: Git and Github'
date: 1969-12-28 00:03:00 +0200
permalink: /git-en/
tag: material
---

# Learning goals

<div>
<h4>The goal is that after this week, the student will</h4>

<ul>
<li>Understand the motivations for using version control.</li>
<li>Know how to create a Git project.</li>
<li>Understand what a commit is and knows how to create one.</li>
<li>Understand the different states a change goes through before it's added to a commit.</li>
<li>Understand what the master branch is.</li>
<li>Know how to read the output of the command <code>git status</code></li>
<li>Know how to create a repository on GitHub and add it to an existing Git project.</li>
<li>Know how to use GitHub through an SSH connection.</li>
<li>Know how to publish locally made commits.</li>
<li>Know how set locally made changes aside to the stash, and how to get them back.</li>
<li>Know what a merge commit is.</li>
<li>Know what a merge conflict is.</li>
<li>Understand how a merge conflict is formed.</li>
<li>Know how to solve a merge conflict.</li>
<li>Know how to view old commits on GitHub and the command line, and how to move back to the latest commit of master after checking out old ones.</li>
<li>Know how to clone a Git project to their local machine.</li>
<li>Understand how GitHub can be used in team projects.</li>
<ul>
<li>Know what an issue is.</li>
<li>Know what forking a project means.</li>
<li>Know what a pull request is.</li>
</ul>
</ul>
</div>

## Version control: Git and GitHub

This part of the course handles version control. Version control refers to a service, which stores code. There are two primary reasons for using it: Version control allows sotring backups of both the current and older versions of a program. In addition, code and projects can easily be shared with others, which makes collaboration easy.

Version control tools allow marking a specific state of a project as such that one can return to it later. Thus, if something goes wrong when developing new features, one can return to an older and functional version of the project. Version control stores all the marked states. Therefore all the developers can follow the evolution of the program, who has done what and when. This also makes finding bugs, or errors in the program, a lot easier.

Contrary to what many people think, programming is mostly done in groups. With version control tools it is possible to use and develop others' code, even without ever meeting in person. People can give verbal feedback, such as report issues, as well as make concrete suggestions for improvement by providing code to the project. All developers are kept up to date about the state of the project, which makes cooperation smoother.

Visul Studio hassummarized reasons for using version control on their [website](https://www.visualstudio.com/learn/what-is-version-control/?rr=https%3A%2F%2Fwww.google.fi%2F). Bitbucket [has also written](https://www.atlassian.com/git/tutorials/what-is-version-control) a longer text about version control.

Git is a version control tool. This part handles using Git and Github, a service related to Git especially in the context of programming projects.

## About Git

Git was initiated by Linus Torvalds, who studied at the department of Computer Science at the University of Helsinki in the nineties. Torvalds is most likely more famous for being the primary developer of the Linux kernel, which is the "heart" of many operating systems, such as Google's [Android](<https://en.wikipedia.org/wiki/Android_(operating_system)>). Almost all the department's computers have a Linux operating system installed in them. 

Torvalds started developing Git for his own needs initially when coding the Linux kernel. He needed a tool for storing different versions of his own code, and sharing it with other people.

GitHub is a service which was created later on, which one can store and publish projects with. There are several sites similar to GitHub, such as [GitLab](https://about.gitlab.com/). However, this part deals with using GitHub as it is more popular at out department.

Git and GitHub are used for solo as well as collaboration projects at the department of computer science and in the industry. It's usage isn't limited only to code however, and many people like to for example backup their thesis using Git. However, this part focuses on sharing code with GitHub, and some of the common problems in it. Git will certainly be useful in your studies, and you will learn more about it in the software engineering courses.


<div class="exercise">
<h3>Exercise 1: Creating a GitHub account {% include points.html text="5%" %}</h3>

Start by creating a GitHub account at <a href="https://github.com/"> https://github.com/ </a>. Programmers often use GitHub as a sort of code protfolio, so make sure to choose a username which you don't mind inserting to your CV.

<br><br>
Git should be already installed on the department's computers and Ubuntu. If this is not the case, you can install it according to these  <a href="https://git-scm.com/downloads" >instructions</a>, or using a <a href="/komentorivi#asentamisesta">package manager</a> kautta.  We'll use Git from the command line.

</div>

<div class="exercise">
<h3>Exercise 2: Configuring Git {% include points.html text="5%" %}</h3>

Let's configure Git a bit.

Link your name and email address to Git so that all the changes you make to different projects are properly associated with you. This can be done by running the following commands:
</div>

```bash
git config --global user.name "My Name"
git config --global user.email email@address.com
```

<div class="exercise">
If you don't want your email to be public, GitHub offers a specific <a href="https://help.github.com/articles/about-commit-email-addresses/">noreply email</a>.

<div class="note">
Make sure you noticed the "Note" part on the site linked above! The form of the noreply email depends on when you created your user. If you created an account only on this course, you can have a no-reply email only after setting your email as private from your account's settings.
</div>

If you're not accustomed to using Vim, change the default editor of Git to nano with the following command:
</div>
```
git config --global core.editor nano
```
<div class="exercise">
In Windows replace <code>nano</code> with <code>notepad</code>.

</div>

## Starting a Git project

You can turn a directory into a Git project by running the command `git init` inside it. This will allow running git commands inside the folder. In consequence, a subfolder `.git` is created. This folder stores all sorts of information about the project in that directory.

### Commits

Information is stored to Git with _commits_. A commit is a sort of bundle of changes made into files in the project. In practice these changes are often adding or removing text from a file

You can think of a commit as a step towards a finished project. Every commit adds some changes to the previous commit. For example, when developing a program, it would be natural to add a new feature in a new commit.

Let's go through how a commit is created. First, the changes one wants to include in the commit are added to the _staging_ state. When all the desired changes are in staging, the commit is wrapped together, sealing all the changes together. 

The command `git status` is very useful, as it gives information avout the current state of the project and all the files inside it.

Let's create a Git project folder, and add an empty file called `lapio_w2.txt` inside. You can do this with the command `touch` for example. When a new file is added to a fresh Git project, `git status` will print the following:

```bash
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

	lapio_w2.txt

nothing added to commit but untracked files present (use "git add" to track)
```

Next we'll take a closer look on the output of `git status`.

### The different states of changes

Changes can be added to the next commit by running `git add`. The command requires one argument, that is the name of the file containing the changes one wished to move to staging and the next commit. Before a file has been added to Git, it is under `Untracked files`. This also means that the changes inside that file will not be added to the next commit.

Now let's add the changes in the file we created earler by running `git add lapio_w2.txt`. Then we'll insert some text into the file with `echo "this is the second part of lapio" >> lapio_w2.txt`. Then we'll run `git status`:

```bash
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   lapio_w2.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lapio_w2.txt
```

Next we'll add one more file to the project, called `empty.txt`. We'll then run `git status` again, which outputs the following:

```bash
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   lapio_w2.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lapio_w2.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	empty.txt
```

Now let's break down the output.

First there is the title `Changes to be committed.` The changes under this title will be added to the next commit.

`Changes not staged for commit` refers to the changes which Git is aware of, which will **not** be added to the next commit.

Finally `Untracked files` contains all the files which are unknoen to Git, meaning that the changes inside them are not being followed. For example, Git cannot distinguish what sort of changes have been done to the untracked files. In consequence, the changes are not being added to the next commit.

You probably noticed that the file `lapio_w2` is in the output twice. This is because Git tracks _changes_. The first change added to Git was where the file `lapio_w2` was created. Only after adding the change to Git was some text insterted into the file. Thus only the change where the file `lapio_w2` was created will be added to the next commit, and not the change when some text was added inside it. The interpretation of the output of `git status` is made easier with some colors. The changes which will be added to the next commit are displayed in green, and next to the filename is written what was done to the file (for example `new file`, `modified`, `deleted`).

Changes can also be cancelled with Git. Adding some text to `lapio_w2.txt` could be cancelled by running `git checkout -- lapio_w2.txt`. The file will be empty after running the command because the command cancelled the change which added some text into `lapio_w2.txt`. In conclusion, the command `git checkout --` enables cancelling changes in tracked files.

By running `git add -p` one can choose change by change, if one wishes the change to be added to Git (y=add, n=don't add). The command only takes into consideration changes in files which are tracked, or _have already been added to Git once_. Thus new files cannot be added to Git with `git add -p`. Running `git add file` will add all the changes in the file. It is also possible to add entire folders to Git using the same command.

<div class="warning">
If you think there is a possibility that you will want to share a project with other people some day, don't add anything secret to Git. Even if you remove the secret content in the next commit, the delicate information stays in the project's history, and can be found from GitHub easily.
</div>

A good habit to form is to constantly check which changes will be added to the next commit with `git status`. This might save you a lot of trouble later on.

### Creating a commit

After choosing which changes will be included in the next commit, you can finally create the commit with the command `git commit`. Every commit has a message attached, which describes the changes included in the commit. The message is added as the commit is created by running: `git commit -m "a descriptive message"`, where your descriptive message specifies what has changed since the last commit. If you leave out the flag `-m` and the message, a text editor will open. In the editor you can write a longer, detailed description below the title message. The commit is then created by saving and exiting the text editor.

[Täältä](https://github.com/erlang/otp/wiki/writing-good-commit-messages) löytyy nopeat ohjeet hyvän commit-viestin kirjoittamiseksi.

We'll continue where the previous example left off. Let's add all the changes we made to the next commit, except creating the file `empty`. Before running `git commit`, the output of `git status` is:

```bash
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   lapio_w2.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	empty.txt
```

Then we'll run `git commit -m "Add new empty file"`

Now the output of `git status` is:

```
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

	empty.txt

nothing added to commit but untracked files present (use "git add" to track)
```

The changes which were commited are no longer visible in the output. However, they are not lost, on the contrary, they have been moved to the commit. You can view the commits of a project with the command `git log`:

```
commit 51bf544c786a671c28f70713b6cb33d87cc38
Author:
Date:

    Add new empty file
```

The command `git log` outputs the author of the commit, the time of its creation and its title. Every commit has a unique id, formed with [SHA-1](https://en.wikipedia.org/wiki/SHA-1). In the output of `git log` the id can be seen as a long string next to the word "commit", which is `51bf544c786a671c28f70713b6cb33d87cc38` in this case.

<div class="note">
The process of creating a commit might seem unintuitive at first. Te next thought experiment might help: Picture the commit as a package. You are sitting on the flor, all the changes layed out in front of you in wooden blocks. The <code>Changes to be commited</code> state is a piece of wrapping paper, which is spread out in front of you. With the command <code>git add</code> you can move changes on top of the wrapping paper, and with <code>git commit</code> you tie the wrapper aroung the changes to create a commit.
</div>

### Branches

At the top of of the output of `git status`, you can see the following text: `On branch master`. Branches allow separating some commits from others. This means that a new branch can be developed independently from an old branch. All projects usually have a main branch, or the `master` branch, which contains the version currently in use.

Branches are usually used for testing out new features, so that a working version of the program is not broken. Since branches don't affect each other states, the new branch can be played with without worrying about old branches. When the changes made to the new branch are deemed ready, the branch can be merged to the master branch, and thus the new features will be published. This course will not focus on branches. It suffices to understand that we will only use the master branch in the exercises and in the exam.

<div class="exercise">
<h3>Exercise 3: Practising working with commits {% include points.html text="10%" %}</h3>
<ol>
<li>Create a folder on the command line and turn it into a Git project.</li>
<li>Create a file called <code>story.txt</code> in your project. Add a lot of text inside.</li>
<li>Add another file called <code>shopping_list.txt</code> to the project, and write down what you need from the store (or just many rows of text).</li>
<li>Create a subfolder called <code>school</code> into the project, and create a file called<code>lapio.txt</code> inside. You will need these files in the future exercises.</li>
<li>After doing all the changes described above, create a total of three commits: one, where you add the story, a second on where you add the shopping list, and a third one where you add the school folder. Make sure that each commit message is truly descriptive.</li>
<li>Using the command <code>git log</code>, check that you have properly created three commits.</li>
<li>Add something new to the shopping list, and create another commit. Use the command <code>git add -p</code>.</li>
<li>Make sure you can see all the commits in the output of <code>git log</code>.</li>
</ol>

<div class="note">
If you see the following message when creating a commit <code>error: cannot run : No such file or directory error: unable to start editor</code>, make sure you configured the default text editor of Git properly (go back to exercise 2).
</div>
</div>

<div class="exercise">
<h3>Exercise 4: Removing changes {% include points.html text="10%" %}</h3>
<ol>
<li>Find out how you can remove changes from the state where they are being added to the next commit (under <code>Changes to be commited</code>), and move them under the headline <code>Changes not staged for commit</code>? Hint: <code>git status</code> will help.</li>
<li>Add some new products to the shopping list, and add them to the next commit (so that they are under <code>Changes to be commited</code>). <strong>Don't create the commit yet.</strong></li>
<li>Then remove the changes from the next commit.</li>
<li>Then remove the changes, using Git, so that when you open the shopping list, the new products are not there.</li>
</ol>
</div>

## Sharing code via GitHub

### Creating a remote repository

In order to share a project through GitHub, a repository (or simply a repo) has to be created for it, and it has to be linked to the local project. After a remote repository has been added to a project, information can be shared between them. In consequence, two concurrent versions of the project will exist: the remote in GitHub and the local version a local version on a specific computer.

This shows how GitHub functions as a backup storage. When the state of a project is updated to its remote in GitHub, it can be accessed from anywhere with internet. Thus the project can be continued even if its local version is destroyed or damaged.

You can create a repository to GitHub by pressing the button on the upper right corner:

![Creating a new repository](/assets/new-repo.png)

A window will open where you can add the repository a name and a description. A repository can be public or private: a public repository can be accessed by anyone, whereas a private repository can only be seen by people chosen by the owner.

You can also create a _README_, a _license_ and a _.gitignore_ file when creating a repository. The point of a README file is to display useful information about the project. A good README contains a short description of the project, installing instructions and a link to the documentation for example. A license refers to a document stating the responsabilities and rights of the creator and the users of the project. The `.gitignore` allows automatically ignoring some files when creating a commit, and it is often quite useful. You can read more about it
[here](https://www.atlassian.com/git/tutorials/saving-changes/gitignore).

<div class="note">
When you wish to update a pre-existing project to GitHub, it is not a good idea to let GitHub create files such as a README automatically. This will lead to problems, because GiHub contains files initially which are not found in the local project. You'll learn more about these kinds of situations later in this part.
</div>

The button `Create repository` adds the project to your personal account. When you navigate to the empty project, you can see some useful instructions about adding a new porject to tour profile. You can find all your projects from your profile, or navigate to them directly with `https://www.github.com/username/projectname`.

### Adding a remote

A remote can be linked to a local project with the command `git remote add`.

The command takes the name and the address of the remote repository as arguments. GitHub offers two options for the repository address protocol: SSH and HTTPS. The first option should be familiar to you from the first part of the course, where the command `ssh` was used. This type of connection is possible to use also with GitHub, if the local system has an SSH key pair, and the public key has been added to GitHub. If the user uses the HTTPS connection type, they will be authenticated with their GitHub username and password. Using an SSH connection is therefore a little less tedious, since the private key can be added to the ssh-agent. You can read more about SSH keys from the first part.

We'll choose the SSH address for the remote project:

![SSH address in GitHub](/assets/ssh-clone.png)

A new repository called "origin" is added using an SSH connection by running the command `git remote add origin git@github.com:user/project.git`. An HTTPS address would be almost identical to the URL in your browser. A remote can be called practically anything besides "origin", but it is a good and a common choice. It is possible to add several remotes, when properly naming them becomes important.

<div class="exercise">
<h3>Exercise 5: SSH key to GitHub {% include points.html text="5%" %}</h3>
<p>
If you haven't created an SSH key pair on your computer, do it first. The instructions can be found from <a href="/command-line">the first part</a>.
</p>
<p>
Add your public SSH key to your GitHub account. <a href="https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account">GitHub has instructions for it</a>.
</p>
<p class="note">
If you don't want to install a new program (as suggested by the instructions), you can print the SSH key to your terminal with the command <code>cat</code>, copy it by hand, and continue following GitHub's instructions from step 2.
</p>
</div>

<div class="exercise">
<h3>Exercise 6: Creating a remote in GitHub {% include points.html text="5%" %}</h3>
<p>Create a remote repository for the project you created locally. </p>

<p><b>Don't let GitHub create a README, license or a .gitignore file when creating the repository. Doing so will cause problems later.</b></p>

<p>

Add the repository as a remote of your project. If you did the previous exercise, use an SSH address, otherwise use HTTPS.</p>
</div>

## Working with a remote

### Publishing

After a project has been added to a repository in GitHub, commits can be published by _pushing_ them to the remote repository.

Changes can be pushed to a specific branch in the remote repository as follows: `git push remotenae branchname`. In this part we will only use the master branch. If you add the flag `-u` after the command `push`, next time you do not need to specigy the name of the remote and branch to push changes to the same place. We recommend using the flag `-u`.

Let's push the changes we made to the file `lapio_w2.txt` by running `git push -u origin master`, since we named the remote `origin` and we are using the master branch. Next we'll navigate to the project site on GitHub. There we will find the file `lapio_w2.txt`.

<div class="exercise">
<h3>Exercise 7: Publishing a commit {% include points.html text="5%" %}</h3>
<ol>
<li>Push the three commits you made earlier to the master branch of the remote repository.</li>
<li>Check on GitHub that you can find all the changes in the remote.</li>
</ol>
</div>

### Fetching code from GitHub

There now exists two versions of the project: one locally, and one in the remote at GitHub. Let's see what happens, when thsese two versions don't stay properly synced.

We'll start by making changes to the project via GitHub. You can edit files on GutHub by clicking on their name and then clicking on pen icon on the right side of the page.

![Pen icon at GitHub](/assets/edit.png)

Next we'll add a new line of text to `lapio_w2.txt`, and create a commit of the change using the green button at the bottom of the page. However, you can't see these changes locally.

We'll run the following commands:

```bash
git fetch
git status
```

The command `git fetch` fetches the newest state of the project from GitHub, but doesn't change the local version. **If you find that `git status` doesn't show up-to-date information about the state of the remote, you should run `git fetch first.`**

We still can't see the new line of text locally. However, if you pushed with the flag `-u`, Git will notice, that the remote repository contains some changes it doesn't see locally:  `Your branch is behind 'origin/master'`is printed at the top of the status output.

You can get the new changes to the local version by running `git pull`. If you used the flag `-u` with `push` earlier, there is no need to specify a remote or a branch. We'll run `git pull`, which results in an output along the lines of the following:

```bash
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From github.com
 * branch            master     -> FETCH_HEAD
   8793615..c661629  master     -> origin/master
Updating 8793615..c661629
Fast-forward
 lapio_w2.txt | 1 +
 1 file changed, 1 insertion(+)
```

Now you can find the new line of text in the file you changed via GitHub.

<div class="exercise">
<h3>Exercise 8: Fetching code from GitHub {% include points.html text="5%" %}</h3>
Create a new file to the school subfolder on GitHub, and fetch it to your local version.
</div>

In practice the situation handled above corresponds to working on a collaborative project, where someone else has added commits to the project and pushed them to GitHub. Other developers should then fetch the new changes with the command `git pull`.

## Stash

Next we'll find out what happens, if GitHub contains some information not found in the local version, and vice versa.

Let's change the first row of `lapio_w2.txt` via GitHub. This will create a new commit to the remote version. Then let's add a new line at the end of the same file in the local version, **but without creatin a new commit of the new change**.

Now if we try to fetch the latest changes with the command `git pull` we'll get:

```bash
From github.com:
 * branch            master     -> FETCH_HEAD
Updating 061ca96..6920cd0
error: Your local changes to the following files would be overwritten by merge:
	lapio_w2.txt
Please, commit your changes or stash them before you can merge.
Aborting
```

Pulling does not work, because the local verison holds changes to the same file as the remote repository, and the local changes have not been created into a commit.

In situations like this one can put the local changes aside to the _stash_. This is done with the command `git stash`. When the command is run, the local changes in files tracked by Git will by hidden, but not lost completely. In order to also stash changes in untracked files, add the flag `-u`. Changes can be returned from the stash by running `git stash pop`.

<div class="exercise">
<h3>Exercise 9: Using stash when pulling from the remote {% include points.html text="10%" %}</h3>
<ol>
<li>Make changes to some files which you have already added to Git once (i.e. they are not under the headline <code>untracked</code> in the output of <code>git status</code>).</li>
<li>Stash the changes you just made using Git.</li>
<li>Open the files you last and check if you can still see the changes</li>
<li>Edit the <i>first</i> sentence of the file <code>story.txt</code> in GitHub and create a commit.</li>
<li>Then edit the <i>last</i> sentence of the same file locally, but <strong>don't create a commit</strong>.</li>
<li>Fetch the changes you made to <code>story.txt</code> in the remote repository to the local version. Use the stash.</li>
<li>After you have successfully fetched the changes to the local version, create a commit of the changes you made to the last sentence of <code>story.txt</code>.</li>
<li>Push the end result to GitHub.</li>
<li>Make sure you can see both the changes you made to the first sentence and the ones to the last sentence in the remote version.</li>
<div class="note">
If you see "CONFLICT" outputted to the terminal when popping changes from the stash, the section "merge conflict" will help.
</div>
</ol>
</div>

## Merge

We'll continue working with two parallel states, as they are probably the biggest stumbling block for new users of Git.

In the previous example, the remote and local versions had different states, because both contained infromation which the other did not have. Because local changes hadn't been commited, they could be put aside to the stash. What had happende, if the local changes had been commited?

The situation can be solved by _merging_ the commit in the remote version and the commit in the local version. Merging simply means combining parallel states. If the two states do not conflict, meaning that they do not contain changes overriding each other, Git can merge them automatically. A new commit, called a merge commit, is created in a merge.

Actually the command `git pull` has built-in merge functionality. It suffices to run `git pull` in order to combine the state of the remote to the state of the local version. In order to finish the automatic merge, the merge commit has to be given a message. Thus when you run `git pull`, a text editor will open, where Git has added a suggestion for the commit message. You can edit this message as you please, and create the commit by saving the message and exiting the editor, which concludes the merge.

Let's test merging in practice. We'll start by creating two non-conflicting commits by creating two new files, one in the remote repository and the other in the local version. After creating the two commits, running `git status` will output:

```
On branch master
Your branch and 'origin/master' have diverged,
and have 1 and 1 different commit each, respectively.
  (use "git pull" to merge the remote branch into yours)
nothing to commit, working directory clean
```

Notice how Git is kind enough to notify us of the two parallel, differing states, and it even advices us on how to proceed.

<div class="note">
Remember that if <code>git status</code> doesn't display the newest state of the remote, you shoud run <code>git fetch</code> first.
</div>

Pushing the now commits will not work, as the command `git push` will output the following:

```
To git@github.com:user/repo.git
 ! [rejected]        master -> master (non-fast-forward)
error: failed to push some refs to 'git@github.com:user/repo.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
```

However, Git gives instructions on what to do next. We'll fetch the new state of the remote and combine it with the local version by running `git pull`. When a text editor opens, we'll give the merge commit a message, save it, and exit. The following will be printed out to the terminal:

```
From github.com:user/repo
 * branch            master     -> FETCH_HEAD
Merge made by the 'recursive' strategy.
 new_file.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 new_file.txt
```

Now according to the output of `git status` we have  mukaan ollaan tehty 2 committia (`ahead by 2 commits`). Ensimmäinen niistä on se, joka luotiin paikallisesti, ja toinen on uusi, automaattisesti luotu merge-commit.

<div class="exercise">
<h3>Exercise 10: Merging {% include points.html text="5%" %}</h3>
<ol>
<li>Create two non-conflicting commits, one directly to the remote repository, and another to the local version. For example, edit the first line of your shopping list via GitHub, and the last line on the local version.</li>
<li>Try pushing the local commit to the remote repository and observer the error message.</li>
<li>Pull the commit from the remote repository to your local version and write "my first merge" as the commit message.</li>
<div class="note">
If you see "CONFLICT" printed out while pulling, read the next section "Merge Conflict".
</div>
<li>Finally, push all the changes to GitHub.</li>
</ol>
</div>

## Merge Conflicts

Tehtäessä yhteistyötä aina välillä käy niin, että kaksi koodaria muokkaavat samoja rivejä. Miten Git tietää mergeä tehdessään, kumpi muutos halutaan pitää? No, ei se tiedäkään, eli joskus automaattinen merge ei onnistu. Etärepositorion ja paikallisen version ristiriitaista tilaa mergettäessä kutsutaan _merge-konfliktiksi_. Silloin jonkun täytyy käsin valita pidettävät muutokset, eli ratkottava merge-konflikti.

Kirjoitetaan GitHubissa tiedostoon `lapio_w2.txt` jollekin riville `terveisiä GitHubista`, ja tehdään muutoksesta commit.
Muokataan sitten _täsmälleen_ samaa riviä paikallisessa versiossa kirjoittamalla `terveisiä mun koneelta` ja tehdään commit.

Nyt kun yritetään yhdistää etärepositoriosta uusin tila paikalliseen versioon komennolla `git pull`, tulostuu:

```bash
Auto-merging ...
CONFLICT (content): Merge conflict in lapio_w2.txt
Automatic merge failed; fix conflicts and then commit the result.
```

`CONFLICT` kertoo missä tiedostossa päällekkäiset muutokset ovat tapahtuneet.
Avataan tämä tiedosto. Siellä näkyy:

```bash
<<<<<< HEAD
terveisiä mun koneelta
======
terveisiä GitHubista
>>>>>> baaf2c96cw031e11138d42c1a35065b9bf8b4400b
```

Toisensa poissulkevat commitit on siis eroteltu <, > ja = -merkkien avulla. HEAD tarkoittaa tämänhetkistä committia (eli nykyisen haaran viimeisintä committia), ja kirjain-numero-yhdistelmä on toisen etärepositoriossa tehdyn commitin id. Hienostuneemmat editorit, kuten VSCode mahdollistavat konfliktien ratkaisemisen yhdellä klikkauksella, mutta muuten ainoa vaihtoehto on poistaa sen ne rivit, joita ei haluta pitää jatkossa.

Poistetaan kaikki merkeillä <, = tai > alkavat rivit, ja muokataan terveisiä. Konfliktien ratkaisija siis saa päättää, mitä konfliktin sisältämään tiedostoon jää. Jätetään tiedoston sisällöksi seuraava:

```
terveisiä mun koneelta ja GitHubista
```

Kun ajetaan `git status`, Git muistuttaa, että ollaan ratkaisemassa konflikteja tiedostossa `lapio_w2.txt`:

```
On branch master
Your branch and 'origin/master' have diverged,
and have 1 and 1 different commit each, respectively.
 (use "git pull" to merge the remote branch into yours)
You have unmerged paths.
 (fix conflicts and run "git commit")

Unmerged paths:
 (use "git add <file>..." to mark resolution)

	both modified:   lapio_w2.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

Lisätään ratkaisu Gittiin komennolla `git add` (huomaa, että vivun -p käyttäminen ei toimi). Kun sen jälkeen ajetaan `git status`, tulostuu

```
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

	modified:   lapio_w2.txt
```

Lopetaan siis konfliktin ratkaiseminen tekemällä commit. Pusketaan tämän jälkeen ratkaisu GitHubiin.

Merge-konfliktit ovat raivostuttavia, mutta yleisiä. Helpoiten niiltä välttyy aina hakemalla uusimman tilan etärepositoriosta, ennen kuin jatkaa koodaamista. Aina se ei ole kuitenkaan mahdollista, jolloin on vain kärsivällisesti käytävä konfliktitilanteet läpi.

Merge-konflikteja voi tulla myös, kun muutoksia ottaa pois stashista, jos syrjään asetetut muutokset ovat ristiriidassa nykyisten muutosten kanssa.

<div class="exercise">
<h3>Exercise 11: Merge-konflikti {% include points.html text="10%" %}</h3>
Aiheuta projektissasi merge-konflikti, ja ratkaise se. Puske lopputulos GitHubiin.
</div>

## Gitin historia

Kun projekti etenee ja siihen luodaan lisää commiteja, ne synnyttävät yhdessä projektin historian. Gitin historia tarkoittaa siis ketjua, joka syntyy kun committeja on luotu peräjälkeen.

Projektin historian säilyttäminen on yksi versionhallinan suurimmista eduista. Se mahdollistaa esimerkiksi historiassa takaisin palaamisen, jos kehityksessä on lisätty jokin toimimaton ominaisuus.

### Historian tarkasteleminen

Projektin historia näkyy helposti Githubissa. Tarkastellaan historiaa ensin sitä kautta.

Navigoidessa projektin sivulle yläpalkissa on ensimmäisenä vasemmalla välilehti, josta pääsee tarkastelemaan committeja.

![Commitit GitHubissa](/assets/commits.png)

Kun välilehdettä painaa, näkee allekkain kaikki tehdyt commitit. Oikeassa reunassa näkyy kolme nappia.

![Commitin tarkasteleminen](/assets/browse-commit.png)

Napeista keskimmäisessä näkyy tietyn commitin id:n alkuosa. Kyseistä nappia painamalla on mahdollista nähdä kaikki commitissa tehdyt muutokset. Lisäykset näkyvät vihreällä, ja poistot punaisella.

![Muutosten tarkasteleminen](/assets/changes_in_github.jpeg)

Painamalla seuraavaksi "Browse files", tai edellisestä näkymästä oikeanpuolimmaista `<>`-painiketta, pääsee tarkastelemaan _koko projektia_ kyseisessä commitissa. Commit siis sisältää pelkästään muutokset, mutta Git mahdollistaa koko projektin tilan tarkastelemisen tietyn commitin jälkeen. Pääset palaamaan takaisin masteriin, eli päähaaran viimeisempään committiin painamalla painiketta vasemmalla, jossa lukee Tree, ja valitsemalla `master`.

![Miten vaihtaa takaisin masteriin](/assets/back-to-master.png)

Saman voi tehdä myös komentorivillä. Kun ollaan Git-projektin kansiossa, tiettyyn committiin voidaan siirtyä komennolla `git checkout commitin_id`. Tämä vastaa samaa, kuin GitHubissa koko projektin tilan tarkasteleminen tietyn commitin jälkeen. Samalla tavalla takaisin viimeisimpään committiin pääsee komennolla `git checkout haarannimi`, eli yleisimmässä tapauksessa `git checkout master`. Yksittäisen commitin muutoksia voidaan tarkastella komennolla `git show commitin_id`.

<div class="exercise">
<h3>Exercise 12: Salaisuus {% include points.html text="10%" %}</h3>
<ol>
<li>Luo projektiisi uusi tiedosto <code>salaisuus.txt</code>, ja kirjoita sisään esimerkiksi "tämä on hyvin salainen salaisuus".</li>
<li>Tee commit salaisuuden lisäämisestä.</li>
<li>Poista sen jälkeen tiedosto <code>salaisuus.txt</code>, ja tee poistosta uusi commit.</li>
<li>Puske muutoksesi GitHubiin.</li>
<li>Navigoi GitHubissa projektiisi. Etusivulla salaisuutta ei näy. Käy etsimässä salaisuus projektin historiasta. Etsi salaisuus sen jälkeen myös komentoriviltä.</li>
</ol>
</div>

<div class="warning">
Tämä on muistutus, että etärepositorioon ei pidä puskea mitään salaista: ei salasanoja, henkilökohtaisia API-avaimia, tai opiskelijanumeroa, tai muutakaan, mitä ei halua julkaista koko maailmalle.
</div>

## GitHubin workflow

GitHubin kaltaiset palvelut helpottavat merkittävästi yhteisten projektein kehittämistä. Käyttäjät huomaavat projektien ongelmat parhaiten. Projektille voi tehdä GitHubissa _issuen_, ja kertoa ohjelman vajaavaisuuksista. Jos tietää ongelman ratkaisun, voi sitä ehdottaa projektin omistajalle koodin muodossa.

GitHubissa sijaitsevan projektin voi kopioida kokonaisuudessaan omalle koneelleen komennolla `git clone`. Komento ottaa argumentiksi repositorion osoitteen, jonka saa projektikansion oikeasta yläkulmasta vihreästä napista. Kyseessä on siis sama osoite, joka annettiin aikaisemmin `git remote add`-komennolle argumentiksi. Projektin omistaja ei saa ilmoitusta siitä, että hänen projektinsa on kloonattu.

Jatkossa, kun aloitat uuden Git-projektin, voit joko luoda sen komentoriviltä komennolla `git init` ja lisätä sen jälkeen projektille etärepositorion, tai sitten voit ensin luoda GitHubissa repositorion, ja kloonata sen sitten koneellesi.

![Kloonausosoite](/assets/clone.png)

Jotta kloonaamaansa repositorioon tekemänsä muutokset voi puskea takaisin etärepositorioon, projektin omistajan tulee [lisätä kloonaaja projektin kehittäjäksi](https://help.github.com/articles/inviting-collaborators-to-a-personal-repository/). Muussa tapauksessa komento `git push` ei onnistu. Yhteisissä koodiprojekteissa voidaan siis luoda Git-projekti, jonka etärepositoriossa kaikki osallistujat ovat kehittäjinä, jolloin kaikki voivat vapaasti lisätä projektiin koodia.

On kuitenkin myös toinen tapa ehdottaa muutoksia olemassaolevaan projektiin: _fork_. Kun forkkaa projektin, kopio siitä lisätään käyttäjän omaksi repositorioksi hänen omaan profiiliiinsa. Tästä tulee ilmoitus GitHubin "feediin", ja projektin omistaja voi nähdä, kuka on forkannut projektin. Kun olet forkannut projektin, voit kloonata oman kopiosi koneellesi tavalliseen tapaan _omasta profiilistasi_, ja puskea muuutoksia _omaan kopioosi_.

Jos oman kopioosi tekemäsi muutokset ovat mielestäsi niin hyviä, että haluat ehdottaa niitä myös alkuperäiseen projektiin, sen voi tehdä [pull requestin](https://help.github.com/articles/about-pull-requests/) avulla. Tällöin alkuperäisen projektin omistaja voi halutessaan liittää mergen avulla muutoksesi projektiinsa.

<div class="exercise">
<h3>Exercise 13: Kloonaaminen {% include points.html text="10%" %}</h3>
<ol>
<li>Selvitä ensin Googlen avulla, miten saat selville komentoriviltä Git-projektin etärepositorioiden nimet ja osoitteet. Kyseessä on siis komento, joka ajetaan Git-projektin sisällä, kun sille on asetettu etärepositorio.</li>
<li>Etsi vapaavalintainen <a href="https://en.wikipedia.org/wiki/Open-source_software">vapaan lähdekoodin</a>-projekti GitHubista (esim. <a href="https://github.com/google/guava">Googlen Guava</a> tai <a href="https://github.com/orfjackal/varjocafe">VarjoCafe</a>). Kloonaa se ensin koneellesi. Selvitä sitten, minkä nimiseksi etärepositorio asetetaan automaattisesti kloonatessa. Voit tehdä tämän ajamalla edellisessä kohdassa selvittämäsi komennon kloonatun projektin sisällä.</li>
</ol>
</div>

<div class="exercise">
<h3>Exercise 14: Toisen projektin tutkiminen {% include points.html text="5%" %}</h3>
Tutki sen jälkeen jonkin vapaan lähdekoodin projektin repoa GitHubissa. Etsi, mistä löydät projektin issuet ja pull requestit. Etsi myös projektiin osallistuneet (<i>contributors</i>) ja heihin liittyvä statistiikka.
</div>

## Loppusanat

Vasta-alkajana yhteistyöprojekteissa versionhallinnan avulla hukkaa ja rikkoo helposti koodia - jos törmäät outoon virheeseen, kysy rohkeasti apua, äläkä ajele sokkona komentoja. Pitkälle pääsee pitämällä silmällä `git status`-komennon tulosteita, puskemalla varmuuskopioita ajoittain, ja kommunikoimalla muiden projektilaisten kanssa muuallakin kuin commit-viesteissä. Gittiä oppii parhaiten käyttämällä sitä, älä siis lannistu ja poista projektia heti epäonnistuessasi. Pahimmassa tapausessa voi aina kloonata projektin uudestaan, kunhan on muistanut siirtää työnsä GitHubiin.

On jälleen aika hengähtää ja pitää tauko. Anna mielesi levätä, ennen kuin palaat materiaaliin ja sen oppimistavoitteisiin.

Lisää Gitistä voi lukea esimerkiksi seuraavista lähteistä:

- <a href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a>
  - Pro Git Book on kohtuullisen raskas, mutta erittäin kattava dokumentaatio Gitistä. Kannattaa käyttää yksittäisen asian opiskelemiseen, kokonaan läpi rämpiminen voi olla turhan pitkäveteinen operaatio.
- <a href="http://ohshitgit.com/">http://ohshitgit.com/</a>
  - Apuja yleisiin ongelmatilanteisiin hauskasti puettuna.
  - Komennot sisältävät jonkin verran Gitin historian ylikirjoittamista, mitä emme tässä osassa käsitelleet, ja saattaa siten joskus viedä ojasta aallikkoon. Voi kuitenkin olla nopea apu epätoivon hetkinä, ja erityisesti ensimmäinen komento, `git reflog`, pelastaa tilanteissa, joissa on onnistunut sekoittamaan koko pakan.
- <a href="https://try.github.io/">https://try.github.io/</a>
  - GitHubin tutoriaali, joka alkaa ihan perusasioista. Käsittelee joitain asioita, joita ei käyty läpi tässä osassa, kuten `git diff` ja komentoriviltä haarojen yhdistäminen.
- Mikäli olet jo tutustunut Gittiin jonkin verran, saatat olla kiinnostunut oppimaan lisää Gitin historiasta. Historian säilyttäminen, jota demonstroitiin esimerkiksi salaisuus-Exercisessä, mahdollistaa myös sen muokkaamisen jälkikäteen. Vanhaa sanontaa mukaillen, _Voittajat kirjoittavat historian, ja mokailijat ylikirjoittavat Gitin historian_. Historian muokkaaminen on kuitenkin varsin vaarallista erityisesti yhteistyöprojekteissa, sillä sen avulla voi pilata muiden ihmisten koneilla olevia versioita. Jos olet kuitenkin edelleen kiinnostunut, Atlassanilla on erikseen tutoriaali [historian ylikirjoittamisesta](https://www.atlassian.com/git/tutorials/rewriting-history), sekä muita [edistyneempiä tutoriaaleja](https://www.atlassian.com/git/tutorials/advanced-overview).

P.S Mikäli olet läsnäoleva opiskelija yliopistossa, kannattaa käydä tarkistasssa GitHub student packin [tarjoukset](https://education.github.com/pack/offers), tarjolla on krediittejä esimerkiksi DigitalOcean ja AWS -palveluihin, sekä etuja myös itse Githubiin.
