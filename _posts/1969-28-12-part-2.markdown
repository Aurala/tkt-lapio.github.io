---
layout: material
title: 'Part 2 - Version control: Git and Github'
date: 1969-12-28 00:03:00 +0200
permalink: /git-en/
tag: material
---

# Learning goals

<h4>The goal is that after this week, the student will</h4>

<ul>
<li>Understand the motivations for using version control.</li>
<li>Know how to create a Git project.</li>
<li>Understand what a commit is and knows how to create one.</li>
<li>Understand the different states a change goes through before it's added to a commit.</li>
<li>Understand what the master branch is.</li>
<li>Know how to read the output of the command <code>git status</code></li>
<li>Know how to create a repository on GitHub and add it to an existing Git project.</li>
<li>Know how to use GitHub through an SSH connection.</li>
<li>Know how to publish locally made commits.</li>
<li>Know how set locally made changes aside to the stash, and how to get them back.</li>
<li>Know what a merge commit is.</li>
<li>Know what a merge conflict is.</li>
<li>Understand how a merge conflict is formed.</li>
<li>Know how to solve a merge conflict.</li>
<li>Know how to view old commits on GitHub and the command line, and how to move back to the latest commit of master after checking out old ones.</li>
<li>Know how to clone a Git project to their local machine.</li>
<li>Understand how GitHub can be used in team projects.</li>
<ul>
<li>Know what an issue is.</li>
<li>Know what forking a project means.</li>
<li>Know what a pull request is.</li>
</ul>
</ul>

# Version control: Git and GitHub

This part of the course handles version control. Version control refers to a service, which stores code. There are two primary reasons for using it: Version control allows sotring backups of both the current and older versions of a program. In addition, code and projects can easily be shared with others, which makes collaboration easy.

Version control tools allow marking a specific state of a project as such that one can return to it later. Thus, if something goes wrong when developing new features, one can return to an older and functional version of the project. Version control stores all the marked states. Therefore all the developers can follow the evolution of the program, who has done what and when. This also makes finding bugs, or errors in the program, a lot easier.

Contrary to what many people think, programming is mostly done in groups. With version control tools it is possible to use and develop others' code, even without ever meeting in person. People can give verbal feedback, such as report issues, as well as make concrete suggestions for improvement by providing code to the project. All developers are kept up to date about the state of the project, which makes cooperation smoother.

Visul Studio hassummarized reasons for using version control on their [website](https://www.visualstudio.com/learn/what-is-version-control/?rr=https%3A%2F%2Fwww.google.fi%2F). Bitbucket [has also written](https://www.atlassian.com/git/tutorials/what-is-version-control) a longer text about version control.

Git is a version control tool. This part handles using Git and Github, a service related to Git especially in the context of programming projects.

## About Git

Git was initiated by Linus Torvalds, who studied at the department of Computer Science at the University of Helsinki in the nineties. Torvalds is most likely more famous for being the primary developer of the Linux kernel, which is the "heart" of many operating systems, such as Google's [Android](<https://en.wikipedia.org/wiki/Android_(operating_system)>). Almost all the department's computers have a Linux operating system installed in them. 

Torvalds started developing Git for his own needs initially when coding the Linux kernel. He needed a tool for storing different versions of his own code, and sharing it with other people.

GitHub is a service which was created later on, which one can store and publish projects with. There are several sites similar to GitHub, such as [GitLab](https://about.gitlab.com/). However, this part deals with using GitHub as it is more popular at out department.

Git and GitHub are used for solo as well as collaboration projects at the department of computer science and in the industry. It's usage isn't limited only to code however, and many people like to for example backup their thesis using Git. However, this part focuses on sharing code with GitHub, and some of the common problems in it. Git will certainly be useful in your studies, and you will learn more about it in the software engineering courses.


<div class="exercise">
<h3>Exercise 1: Creating a GitHub account {% include points.html text="5%" %}</h3>

Start by creating a GitHub account at <a href="https://github.com/"> https://github.com/ </a>. Programmers often use GitHub as a sort of code protfolio, so make sure to choose a username which you don't mind inserting to your CV.

<br><br>
Git should be already installed on the department's computers and Ubuntu. If this is not the case, you can install it according to these  <a href="https://git-scm.com/downloads" >instructions</a>, or using a <a href="/komentorivi#asentamisesta">package manager</a> kautta.  We'll use Git from the command line.

</div>

<div class="exercise">
<h3>Exercise 2: Configuring Git {% include points.html text="5%" %}</h3>

Let's configure Git a bit.

Link your name and email address to Git so that all the changes you make to different projects are properly associated with you. This can be done by running the following commands:
</div>

```bash
git config --global user.name "My Name"
git config --global user.email email@address.com
```

<div class="exercise">
If you don't want your email to be public, GitHub offers a specific <a href="https://help.github.com/articles/about-commit-email-addresses/">noreply email</a>.

<div class="note">
Make sure you noticed the "Note" part on the site linked above! The form of the noreply email depends on when you created your user. If you created an account only on this course, you can have a no-reply email only after setting your email as private from your account's settings.
</div>

If you're not accustomed to using Vim, change the default editor of Git to nano with the following command:
</div>
```
git config --global core.editor nano
```
<div class="exercise">
In Windows replace <code>nano</code> with <code>notepad</code>.

</div>

## Starting a Git project

You can turn a directory into a Git project by running the command `git init` inside it. This will allow running git commands inside the folder. In consequence, a subfolder `.git` is created. This folder stores all sorts of information about the project in that directory.

### Commits

Information is stored to Git with _commits_. A commit is a sort of bundle of changes made into files in the project. In practice these changes are often adding or removing text from a file

You can think of a commit as a step towards a finished project. Every commit adds some changes to the previous commit. For example, when developing a program, it would be natural to add a new feature in a new commit.

Let's go through how a commit is created. First, the changes one wants to include in the commit are added to the _staging_ state. When all the desired changes are in staging, the commit is wrapped together, sealing all the changes together. 

The command `git status` is very useful, as it gives information avout the current state of the project and all the files inside it.

Let's create a Git project folder, and add an empty file called `lapio_w2.txt` inside. You can do this with the command `touch` for example. When a new file is added to a fresh Git project, `git status` will print the following:

```bash
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

	lapio_w2.txt

nothing added to commit but untracked files present (use "git add" to track)
```

Next we'll take a closer look on the output of `git status`.

### The different states of changes

Changes can be added to the next commit by running `git add`. The command requires one argument, that is the name of the file containing the changes one wished to move to staging and the next commit. Before a file has been added to Git, it is under `Untracked files`. This also means that the changes inside that file will not be added to the next commit.

Now let's add the changes in the file we created earler by running `git add lapio_w2.txt`. Then we'll insert some text into the file with `echo "this is the second part of lapio" >> lapio_w2.txt`. Then we'll run `git status`:

```bash
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   lapio_w2.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lapio_w2.txt
```

Next we'll add one more file to the project, called `empty.txt`. We'll then run `git status` again, which outputs the following:

```bash
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   lapio_w2.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lapio_w2.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	empty.txt
```

Now let's break down the output

First there is the title `Changes to be committed.` The changes under this title will be added to the next commit.

`Changes not staged for commit` refers to the changes which Git is aware of, which will **not** be added to the next commit.

Finally `Untracked files` contains all the files which are unknoen to Git, meaning that the changes inside them are not being followed. For example, Git cannot distinguish what sort of changes have been done to the untracked files. In consequence, the changes are not being added to the next commit.

You probably noticed that the file `lapio_w2` is in the output twice. This is because Git tracks _changes_. The first change added to Git was where the file `lapio_w2` was created. Only after adding the change to Git was some text insterted into the file. Thus only the change where the file `lapio_w2` was created will be added to the next commit, and not the change when some text was added inside it. The interpretation of the output of `git status` is made easier with some colors. The changes which will be added to the next commit are displayed in green, and next to the filename is written what was done to the file (for example `new file`, `modified`, `deleted`).

Changes can also be cancelled with Git. Adding some text to `lapio_w2.txt` could be cancelled by running `git checkout -- lapio_w2.txt`. The file will be empty after running the command because the command cancelled the change which added some text into `lapio_w2.txt`. In conclusion, the command `git checkout --` enables cancelling changes in tracked files.

By running `git add -p` one can choose change by change, if one wishes the change to be added to Git (y=add, n=don't add). The command only takes into consideration changes in files which are tracked, or _have already been added to Git once_. Thus new files cannot be added to Git with `git add -p`. Running `git add file` will add all the changes in the file. It is also possible to add entire folders to Git using the same command.

<div class="warning">
If you think there is a possibility that you will want to share a project with other people some day, don't add anything secret to Git. Even if you remove the secret content in the next commit, the delicate information stays in the project's hsitory, and can be found from GitHub easily.
</div>

It's a good habit to constantly check which changes will be added to the next commit with `git status`. This might save you a lot of trouble later on.

### Commitin paketointi

Kun ollaan valittu, mitä muutoksia halutaan lisätä committiin, paketoidaan se komennolla `git commit`. Jokaisella commitilla on otsikko, joka kuvaa siinä tehtyjä muutoksia. Otsikko voidaan lisätä komennolla `git commit -m "kuvaava otsikko"`, jossa kuvaava otsikko kertoo, mitä muutoksia tehtiin suhteessa edelliseen committiin. Jos komennosta jättää vivun `-m` ja viestin sen jälkeen pois, tekstieditori aukeaa, ja voit kirjoittaa otsikon, sekä pidemmän viestin sen alle.

[Täältä](https://github.com/erlang/otp/wiki/writing-good-commit-messages) löytyy nopeat ohjeet hyvän commit-viestin kirjoittamiseksi.

Jatketaan edellistä esimerkkiä. Lisätään seuraavaan committiin kaikki muutokset, paitsi tiedoston `tyhja_tiedosto` luonti. Ennen komennon `git commit` ajamista, komennon `git status` tulostus oli seuraava:

```bash
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   lapio_w2.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	empty.txt
```

Ajetaan seuraavaksi `git commit -m "Lisää uusi lapio-tiedosto"`

Nyt `git status` tulostaa :

```
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

	empty.txt

nothing added to commit but untracked files present (use "git add" to track)
```

Commitoidut muutokset eivät siis enää näy statuksessa. Ne eivät kuitenkaan ole hävinneet: ne on siirretty committiin. Komennolla `git log` pystyt tarkastelemaan luotuja committeja:

```
commit 51bf544c786a671c28f70713b6cb33d87cc38
Author:
Date:

    Lisättiin lapio_w2.txt -tiedosto
```

Komento `git log` siis tulostaa commitin tekijän, luontiajan, sekä commitille annetun otsikon. Jokaisella commitilla on sen identifioiva merkkijono eli id, joka on [SHA-1](https://en.wikipedia.org/wiki/SHA-1)-muodossa. Komennon `git log` tulostuksessa id näkyy pitkänä merkkijonona, esimerkiksi tässä tapauksessa se on `51bf544c786a671c28f70713b6cb33d87cc38`.

<div class="note">
Commitin luominen voi aluksi tuntua epäintuitiiviselta. Seuraava ajatusleikki saattaa auttaa: Kuvittele, että commit on lahjapaketti. Istut lattialla. Muutokset ovat puupalikoita, jotka on levitetty lattialle viereesi. <code>Changes to be commited</code>-tila on eteesi levitetty käärepaperi. Komennolla <code>git add</code> lisäät muutoksia käärepaperin päälle, ja komennolla <code>git commit</code> sidot käärepaperin muutosten ympärille.
</div>

### Haarat

Komennon `git status` tulosteen yläreunassa näkyy: `On branch master`. Haarat, eli englanniksi _branchit_, mahdollistavat joidenkin committien eriyttäimisen toisistaan niin, että voidaan testata uusia toiminnallisuuksia ilman, että menetetään toimiva versio ohjelmasta. Jokaisella projektilla on päähaara eli `master` -haara, jossa pidetään senhetkistä toimivaa ja käytössä olevaa versiota.

Usein haaroja käytetään niin, että päähaarasta erotetaan uuden toiminnallisuuden testaamiseksi toinen haara, jossa koodataan lisäominaisuuksia. Haarat eivät vaikuta toistensa tiloihin, eli uudella koodilla voidaan leikkiä huolimatta päähaarasta. Kun ollaan todettu uusi koodi toimivaksi, voidaan se lisätä päähaaraan, ja poistaa uusi haara. Tässä osassa ei käsitellä haaroja sen enempää: riittää ymmärtää, että käytämme nyt vain master-, eli päähaaraa.

<div class="exercise">
<h3>Exercise 3: Committien harjoittelua {% include points.html text="10%" %}</h3>
<ol>
<li>Luo kansio komentorivillä ja tee siitä Git-projekti.</li>
<li>Luo projektikansioosi tiedosto nimeltä <code>tarina.txt</code>. Lisää sinne jokin pitkä pätkä tekstiä.</li>
<li>Lisää projektiin tiedosto <code>ostoslista.txt</code>, jonne kirjoitat, mitä tarvitset kaupasta, tai muuten vaan paljon rivejä.</li>
<li>Lisää sen jälkeen vielä alikansio <code>kouluprojektit</code>, ja lisää sinne ainakin yksi tiedosto <code>lapio.txt</code>. Tulet tarvitsemaan näitä tiedostoja tulevissa tehtävissä.</li>
<li>Kun olet tehnyt kaikki edellä mainitut muutokset, tee yhteensä kolme committia: yksi, jossa lisäät tarinan, toinen,jossa lisäät ostoslistan, ja kolmas, jossa lisäät projektikansion sisällön. Kirjoita commiteille kuvaavat otsikot.</li>
<li>Tarkista komennolla <code>git log</code>, että olet luonut kolme committia.</li>
<li>Muuta ostoslistalta jokin ostos, ja tee vielä yksi commit. Käytä muutoksen lisäämisessä komentoa <code>git add -p</code>.</li>
<li>Tarkista, että kaikki commitit näkyvät <code>git log</code>-komennolla.</li>
</ol>

<div class="note">
Jos committia luodessa tulostuu virheviesti <code>error: cannot run : No such file or directory error: unable to start editor</code>, varmista, että olet konfiguroinut oletuseditorin oikein (tämä tehtiin Exercisessä 2).
</div>
</div>

<div class="exercise">
<h3>Exercise 4: Muutosten poistaminen {% include points.html text="10%" %}</h3>
<ol>
<li>Selvitä, miten saat poistettua muutoksen tilasta, jossa olet lisäämässä sitä committiin (näkyy vihreänä tulostuksessa), ja siirrettyä muutoksen otsikon <code>Changes not staged for commit</code> alle? Vinkki: <code>git status</code> auttaa.</li>
<li>Lisää uusia tuotteita ostoslistaan, ja aseta muutokset lisättäväksi seuraavaan committiin (<code>Changes to be commited</code>). <strong>Älä kuitenkaan paketoi committia.</strong></li>
<li>Poista sen jälkeen muutokset seuraavasta commitista.</li>
<li>Poista sen jälkeen muutokset Gitin avulla niin, että kun avaat ostoslistan, uusimmat tuotteet puuttuvat.</li>
</ol>
</div>

## Koodin jakaminen GitHubissa

### Etärepositorion luominen

Jotta projektin voi jakaa GitHubin kautta, sille pitää luoda oma repositorio (kavereille repo) GitHubiin, ja tämä repositorio pitää liittää oman koneen Git-projektiin. Tämä tapahtuu lisäämällä repo Git-projektin etärepositorioksi, eli _remoteksi_. Kun Git-projektille lisätään etärepositorio, on mahdollistä siirtää tietoa sen ja omalla koneella olevan projektin välillä. Tällöin projektista on olemassa kaksi versiota: paikallinen (_local_), eli "omalla koneella" oleva projekti ja etärepositorion versio (_remote_), eli GitHubissa säilöttävä versio.

Tässä siis näkyy, miten GitHubia voidaan käyttää varmuuskopiona: kun projektin tila päivitetään GitHubiin, pääsee tietoon käsiksi internetin kautta, ja projektia voi jatkaa, vaikka paikalliselle versiolle tapahtuisikin jotain.

GitHubissa saa luotua repositorion oikeasta yläkulmasta:

![Uuden repon luominen](/assets/new-repo.png)

Avautuu näkymä, jossa lisätään repolle nimi ja kuvaus. Repositorio voi olla joko julkinen tai yksityinen. Julkisen repostorion näkee kuka vaan, yksityisen vain omistajan valitsemat käyttäjät.

GitHub myös tarjoaa mahdollisuuden luoda projektille _README:n_, _lisenssin_ ja _.gitignore_-tiedoston. Ohjelmistotuotannossa on tapana, että ohjelmistoprojektiin lisätään README-niminen tiedosto, joka sisältää yleishyödyllistä tietoa koko projektista. Hyvä README sisältää esimerkiksi lyhyen kuvauksen projektista, asennusohjeet ja linkin mahdolliseen dokumentaatioon. Lisenssi tarkoittaa dokumenttia, jossa määritellään, mitkä ovat ohjelman tekijän ja käyttäjän vastuut ja vapaudet. `.gitignore` on erittäin hyödyllinen tiedosto, jonka avulla Gittiä voi pyytää jättämään joitain tiedostoja huomiotta committeja tehdessä. `.gitignoren` käytöstä voit lukea esimerkiksi [täältä](https://www.atlassian.com/git/tutorials/saving-changes/gitignore).

<div class="note">
Kun halutaan siirtää valmiiksi luotu projektikansio GitHubiin, ei kannata antaa GitHubin luoda tiedostoja automaattisesti. Tämä johtaisi vaikeuksiin, sillä tällöin GitHubissa olisi tiedosto, jota lokaalissa versiossa ei ole. Tällaisen tilanteen ongelmallisuus selviää myöhemmin tässä osassa.
</div>

Nappi `Create repository` lisää projektin omaan profiiliin. Kun projektiin navigoi, tarjoaa GitHub hyödyllisiä ohjeita koodin sinne lisäämiseksi. Projektiin löytää käyttäjän profiilista, tai suoraan osoitteella `https://www.github.com/kayttajanimi/projektinnimi`.

### Etärepositorion lisääminen

Etärepositorio yhdistetään paikalliseen projektiin komennolla `git remote add`.

Komento ottaa argumentikseen lisättävän etärepositorion nimen sekä osoitteen. GitHub tarjoaa kaksi vaihtoehtoa etärepositorion lisäysprotokollaksi: SSH ja https. Ensimmäisen vaihtoehdon pitäisi olla tuttu ensimmäisestä osasta, toisen selaimen osoitekentästä. SSH on siis sama yhteystyyppi, jolla vierailtiin laitoksen koneilla komennolla `ssh`. Tätä yhteystyyppia on mahdollista käyttää, jos koneella on luotu yksityinen ja julkinen avainpari, joista julkinen on lisätty GitHubiin. Jos käyttää https-yhteyttä, autentikointi tapahtuu GitHub-käyttäjänimellä ja salasanalla. SSH-yhteyden käyttö on siis paljon vaivattomampaa, sillä jos yksityisen avaimen lisää ssh-agentille, ei salasanaa tarvitse kirjoittaa jatkuvasti. SSH-avaimia käsiteltiin [ensimmäisessä osasssa](/komentorivi#SSH-avainpari).

Valitaan GitHubin ohjeista SSH-osoite projektille, jotta siihen voidaan muodostaa SSH-yhteys:

![SSH osoite GitHubissa](/assets/ssh-clone.png)

Uusi origin-niminen etärepositorio lisätään SSH-yhteyttä käyttäen ajamalla projektikansiossa komento `git remote add origin git@github.com:kayttaja/projekti.git`. Https-osoite olisi melkein sama, kuin selaimen osoiterivillä. Etärepositorion nimi voi olla muutakin kuin "origin", mutta se on yleinen valinta. Yhdelle projektille voi lisätä useita etärepositorioita, jolloin niiden järkevä nimeäminen on oleellista.

<div class="exercise">
<h3>Exercise 5: SSH-avain GitHubiin {% include points.html text="5%" %}</h3>
<p>
Jos et ole luonut koneellesi ssh-avainparia, tee se ensin. Ohjeet löytyy <a href="/komentorivi#SSH-avainpari">ensimmäisestä osasta</a>.
</p>
<p>
Lisää julkinen ssh-avaimesi GitHubin käyttäjällesi. <a href="https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account">Sille löytyy ohjeet GitHubissa</a>.
</p>
<p class="note">
Voit tulostaa ssh-avaimen terminaaliisi komennolla <code>cat avaintiedoston_nimi</code> ja kopioida sen painamalla <code>ctrl + shift + c</code>, ja jatkaa GitHubin ohjeiden seuraamista kohdasta 2. Tällöin sinun ei tarvitse asentaa uutta ohjelmaa, kuten GitHubin ohjeet ehdottavat.
</p>
</div>

<div class="exercise">
<h3>Exercise 6: Etärepositorion luominen Githubissa {% include points.html text="5%" %}</h3>
<p>Luo aikaisemmin tekemällesi projektille vastapari, eli repositorio GitHubiin. </p>

<p><b>Älä luo projektille GitHubissa valmiiksi lisenssiä, READMEtä tai .gitignore-tiedostoa, muuten kohtaat myöhemmin ongelmia.</b></p>

<p>
Liitä GitHubin repo projektisi etärepositorioksi. Jos teit edellisen Exercisen, käytä SSH-osoitetta, muuten käytä https-osoitetta.</p>
</div>

## Etärepositorion kanssa työskentely

### Julkaiseminen

Kun projekti on liitetty johonkin GitHubin repositorioon, voidaan committeja julkaista _puskemalla_.
Muutokset voi puskea tietyn etärepositorion tiettyyn haaraan seuraavasti: `git push remotennimi haarannimi`. Tässä osassa käytämme vain master-haaraa. Jos lisäät sanan `push` jälkeen vivun `-u`, riittää ensi kerralla ajaa `git push`, jolloin muutokset pusketaan automaattisesti samaan paikkaan. Tämän vivun käyttö on suositeltavaa.

Pusketaan `lapio_w2.txt`-tiedostoon tekemämme muutokset komennolla `git push -u origin master`, sillä lisäsimme etärepositorion nimellä `origin`, ja käytämme `master`-haaraa. Navigoidaan GitHubissa projektisivulle. Tiedosto `lapio_w2.txt` näkyy nyt GitHubissa.

<div class="exercise">
<h3>Exercise 7: Commitin julkaiseminen {% include points.html text="5%" %}</h3>
<ol>
<li>Puske tekemäsi kolme committia etärepositoriosi <code>master</code>-haaraan.</li>
<li>Käy tarkistamassa GitHubissa, että kyseiset commitit näkyvät etärepositoriossa.</li>
</ol>
</div>

### Koodin hakeminen GitHubista

Samasta projektista on nyt siis olemassa kaksi tilaa kahdessa paikassa: paikallinen ja etärepositorio. Katsotaan seuraavaksi, mitä käy, kun nämä kaksi tilaa eivät ole aina täysin samat.

Aloitetaan tekemällä muutoksia projektiin GitHubin kautta. GitHubissa pääsee muokkaamaan tiedostoja painamalla niiden nimeä, ja oikealla olevaa kynä-ikonia.

![Kynä-ikoni Githubissa](/assets/edit.png)

Lisätään tiedostoon `lapio_w2.txt` uusi rivi tekstiä, ja luodaan commit sivun alalaidasta vihreästä napista. Muutokset eivät kuitenkaan näy omalla koneella heti.

Ajetaan seuraavat komennot:

```bash
git fetch
git status
```

`git fetch` hakee projektin uusimman tilan GitHubista, mutta ei tee muutoksia paikalliseen työhön. **Jos `git status` ei jatkossa näytä ajankohtaista tietoa, aja ensin `git fetch`**.

Muutokset eivät vieläkään näy. Jos puskit committisi etärepositorioon vivun `-u` kanssa, Git osaa kertoa, että GitHubissa on muutoksia, joita paikallisessa versiossa ei ole: `Your branch is behind 'origin/master'`.

Nyt voidaan hakea muutokset paikalliseen versioon komennolla `git pull`. Jos aikaisemmin oltiin ajettu `push` vivulla `-u`, ei etärepositoriota tai haaran nimeä tarvitse kirjoittaa. Ajetaan `git pull`, jolloin tulostuu jotain seuraavankaltaista:

```bash
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From github.com
 * branch            master     -> FETCH_HEAD
   8793615..c661629  master     -> origin/master
Updating 8793615..c661629
Fast-forward
 lapio_w2.txt | 1 +
 1 file changed, 1 insertion(+)
```

Nyt muutokset näkyvät myös paikallisesti.

<div class="exercise">
<h3>Exercise 8: Koodin hakeminen etärepositoriosta {% include points.html text="5%" %}</h3>
Luo GitHubissa kouluprojektit-alikansioon uusi tiedosto, ja hae se sitten omaan projektiisi.
</div>

Käytännössä tämä tilanne vastaa sitä, että tehdään yhteisprojektia, ja joku muu on lisännyt projektiin koodia. Tällöin uuden ominaisuuden lisännyt julkaisee koodinsa puskemalla sen GitHubiin, jolloin muut projektin tekijät voivat hakea ne komennolla `git pull`.

## Stash

Kokeillaan seuraavaksi mitä käy, jos GitHubissa on jotain tietoa, mitä paikallisesti ei ole, ja paikallisesti jotain, mitä GitHubissa ei.

Muutetaan tiedoston `lapio_w2.txt` ensimmäistä riviä GitHubin kautta. Tästä syntyy siis yksi commit. Lisätään paikallisesti saman tiedoston loppuun uusi rivi, **mutta ei tehdä paikallisesta muutoksesta committia**.

Jos nyt kokeillaan hakea uusimmat muutokset komennolla `git pull`, tulostuu:

```bash
From github.com:
 * branch            master     -> FETCH_HEAD
Updating 061ca96..6920cd0
error: Your local changes to the following files would be overwritten by merge:
	lapio_w2.txt
Please, commit your changes or stash them before you can merge.
Aborting
```

Pullaus ei toimi, koska paikallisessa versiossa on muutoksia samaan tiedostoon, kuin etärepositoriossa, eikä paikallisia muutoksia ole commitoitu.

Tällaisessa tilanteessa voidaan laittaa paikalliset muutokset syrjään _stashiin_ komennolla `git stash`. Kun ajetaan `git stash`, paikallisesti lisätyt muutokset Gitin seuraamissa tiedostoissa laitetaan syrjään. Tämä siis tarkoittaa, että tehdyt muutoksen poistuvat näkyvistä, mutta niitä ei ole menetetty kokonaan. Laittaaksesi syrjään myös muutokset Gittiin vielä lisäämättömissä tiedostoissa (`untracked`), aja komento vivulla `-u`, eli `git stash -u`. Saat muutokset takaisin käskyllä `git stash pop`.

<div class="exercise">
<h3>Exercise 9: Stashin käyttäminen pullatessa {% include points.html text="10%" %}</h3>
<ol>
<li>Tee muutoksia paikallisesti jo kertaalleen Gittiin lisäämiisi tiedostoihin (eivät ole <code>untracked</code>-otsikon alla komennon <code>git status</code> tulostuksessa).</li>
<li>Laita sen jälkeen juuri tekemäsi muutokset syrjään stashiin.</li>
<li>Avaa sen jälkeen muokkaamasi tiedosto, näetkö tekemiäsi muutoksia?</li>
<li>Muokkaa GitHubin kautta <code>tarina.txt</code>-tiedoston <i>ensimmäistä</i> lausetta ja tee siitä commit.</li>
<li>Muokkaa sitten paikallisesti saman tiedoston <i>viimeistä</i> lausetta, mutta <strong>älä tee committia</strong>.</li>
<li>Hae sen jälkeen etärepositoriossa tekemäsi muutokset <code>tarina.txt</code>-tiedoston ensimmäiseen lauseeseen projektin paikalliseen versioon. Käytä apuna stashia.</li>
<li>Kun olet saanut haettua muutokset, tee viimeiseen lauseeseen tekemistäsi muutoksista uusi commit.</li>
<li>Puske tämän jälkeen lopputulos GitHubiin.</li>
<li>Varmista, että sekä ensimmäiseen, että viimeiseen lauseeseen tekemäsi muutokset ovat näkyvillä Githubissa.</li>
<div class="note">
Jos terminaaliin tulostuu "CONFLICT", saat apua osiosta <a href="#merge-konflikti">merge-konflikti</a>.
</div>
</ol>
</div>

## Merge

Jatketaan vielä kahden rinnakkaisen tilan kanssa.

Äskeisessä tilanteessa etärepositoriossa ja paikallisesti vallitsivat eri tilat, sillä molemmissa oli tietoa, jota toisella ei ollut. Koska paikallisia muutoksia ei oltu commitoitu, voitiin ne piilottaa stashiin. Mitä olisi tapahtunut, jos paikallisesti oltaisiin ehditty commitoida?

Tilanne voidaan ratkaista _mergellä_, eli yhdistämällä kaksi rinnakkaista tilaa. Sellaiset haarat, jotka eivät ole ristriidassa keskenään, eli toisin sanoen eivät tee päällekkäisiä muutoksia, Git osaa yhdistää automaattisesti. Tällöin Git luo uuden merge-commitin.

Oikeastaan komento `git pull` sisältää jo valmiiksi merge-toiminnallisuuden. Riittää siis ajaa komento `git pull`, ja antaa tekstieditorin avautuessa commitille otsikko, jotta saadaan yhdistettyä paikallinen master-haara etärepositorion master-haaraan. GitHub ehdottaa valmiiksi viestiä, jota voi halutessaan muokata mieleisekseen. Merge on valmis, kun merge-commitin viestin tallentaa.

Lisätään sekä paikallisesti että etärepositorioon uudet, keskenään erinimiset tiedostot ja commitoidaan. Kun sen jälkeen ajaa `git status` (aja ensin `git fetch`, jos `git status` ei näytä uusinta tilaa), tulostuu:

```
On branch master
Your branch and 'origin/master' have diverged,
and have 1 and 1 different commit each, respectively.
  (use "git pull" to merge the remote branch into yours)
nothing to commit, working directory clean
```

Git siis huomauttaa, että sekä etärepositorioon että paikallisesti on luotu committeja.

Jos yritetään puskea commit, se ei onnistu:

```
To git@github.com:kayttaja/repo.git
 ! [rejected]        master -> master (non-fast-forward)
error: failed to push some refs to 'git@github.com:kayttaja/repo.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
```

Git antaa jälleen vihjeen, miten kuuluu toimia. Haetaan ja yhdistetään siis etärepositorion uusin tila paikalliseen versioon komennolla `git pull`. Annetaan commitille tekstieditorin auetessa otsikko, ja tallennetaan. Tällöin tulostuu:

```
From github.com:kayttaja/repo
 * branch            master     -> FETCH_HEAD
Merge made by the 'recursive' strategy.
 new_file.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 new_file.txt
```

Nyt komennon `git status` mukaan ollaan tehty 2 committia (`ahead by 2 commits`). Ensimmäinen niistä on se, joka luotiin paikallisesti, ja toinen on uusi, automaattisesti luotu merge-commit.

<div class="exercise">
<h3>Exercise 10: Mergeäminen {% include points.html text="5%" %}</h3>
<ol>
<li>Luo etärepositorioon GitHubissa ja paikallisesti sellaiset commitit, että niissä tapahtuvat muutokset eivät ole ristiriidassa keskenään, eli eivät muokkaa samoja rivejä. Toimi esimerkiksi seuraavasti: muokkaa ostoslistan ensimmäistä tuotetta GitHubissa, ja tee commit. Lisää sitten paikallisesti ostoslistan loppuun uusi tuote ja tee uusi commit.</li>
<li>Kokeile puskea paikallinen committisi etärepositorioon. Minkä virheviestin saat?</li>
<li>Hae sen jälkeen GitHubin muutos paikalliseen versioon, ja kirjoita commit-viestiksi "Ensimmäinen mergeni".</li>
<div class="note">
Jos pullatessa tulostui "CONFLICT" lue seuraava osio "Merge-konflikti".
</div>
<li>Puske lopuksi tekemäsi muutokset GitHubiin.</li>
</ol>
</div>

## Merge-konflikti

Tehtäessä yhteistyötä aina välillä käy niin, että kaksi koodaria muokkaavat samoja rivejä. Miten Git tietää mergeä tehdessään, kumpi muutos halutaan pitää? No, ei se tiedäkään, eli joskus automaattinen merge ei onnistu. Etärepositorion ja paikallisen version ristiriitaista tilaa mergettäessä kutsutaan _merge-konfliktiksi_. Silloin jonkun täytyy käsin valita pidettävät muutokset, eli ratkottava merge-konflikti.

Kirjoitetaan GitHubissa tiedostoon `lapio_w2.txt` jollekin riville `terveisiä GitHubista`, ja tehdään muutoksesta commit.
Muokataan sitten _täsmälleen_ samaa riviä paikallisessa versiossa kirjoittamalla `terveisiä mun koneelta` ja tehdään commit.

Nyt kun yritetään yhdistää etärepositoriosta uusin tila paikalliseen versioon komennolla `git pull`, tulostuu:

```bash
Auto-merging ...
CONFLICT (content): Merge conflict in lapio_w2.txt
Automatic merge failed; fix conflicts and then commit the result.
```

`CONFLICT` kertoo missä tiedostossa päällekkäiset muutokset ovat tapahtuneet.
Avataan tämä tiedosto. Siellä näkyy:

```bash
<<<<<< HEAD
terveisiä mun koneelta
======
terveisiä GitHubista
>>>>>> baaf2c96cw031e11138d42c1a35065b9bf8b4400b
```

Toisensa poissulkevat commitit on siis eroteltu <, > ja = -merkkien avulla. HEAD tarkoittaa tämänhetkistä committia (eli nykyisen haaran viimeisintä committia), ja kirjain-numero-yhdistelmä on toisen etärepositoriossa tehdyn commitin id. Hienostuneemmat editorit, kuten VSCode mahdollistavat konfliktien ratkaisemisen yhdellä klikkauksella, mutta muuten ainoa vaihtoehto on poistaa sen ne rivit, joita ei haluta pitää jatkossa.

Poistetaan kaikki merkeillä <, = tai > alkavat rivit, ja muokataan terveisiä. Konfliktien ratkaisija siis saa päättää, mitä konfliktin sisältämään tiedostoon jää. Jätetään tiedoston sisällöksi seuraava:

```
terveisiä mun koneelta ja GitHubista
```

Kun ajetaan `git status`, Git muistuttaa, että ollaan ratkaisemassa konflikteja tiedostossa `lapio_w2.txt`:

```
On branch master
Your branch and 'origin/master' have diverged,
and have 1 and 1 different commit each, respectively.
 (use "git pull" to merge the remote branch into yours)
You have unmerged paths.
 (fix conflicts and run "git commit")

Unmerged paths:
 (use "git add <file>..." to mark resolution)

	both modified:   lapio_w2.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

Lisätään ratkaisu Gittiin komennolla `git add` (huomaa, että vivun -p käyttäminen ei toimi). Kun sen jälkeen ajetaan `git status`, tulostuu

```
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

	modified:   lapio_w2.txt
```

Lopetaan siis konfliktin ratkaiseminen tekemällä commit. Pusketaan tämän jälkeen ratkaisu GitHubiin.

Merge-konfliktit ovat raivostuttavia, mutta yleisiä. Helpoiten niiltä välttyy aina hakemalla uusimman tilan etärepositoriosta, ennen kuin jatkaa koodaamista. Aina se ei ole kuitenkaan mahdollista, jolloin on vain kärsivällisesti käytävä konfliktitilanteet läpi.

Merge-konflikteja voi tulla myös, kun muutoksia ottaa pois stashista, jos syrjään asetetut muutokset ovat ristiriidassa nykyisten muutosten kanssa.

<div class="exercise">
<h3>Exercise 11: Merge-konflikti {% include points.html text="10%" %}</h3>
Aiheuta projektissasi merge-konflikti, ja ratkaise se. Puske lopputulos GitHubiin.
</div>

## Gitin historia

Kun projekti etenee ja siihen luodaan lisää commiteja, ne synnyttävät yhdessä projektin historian. Gitin historia tarkoittaa siis ketjua, joka syntyy kun committeja on luotu peräjälkeen.

Projektin historian säilyttäminen on yksi versionhallinan suurimmista eduista. Se mahdollistaa esimerkiksi historiassa takaisin palaamisen, jos kehityksessä on lisätty jokin toimimaton ominaisuus.

### Historian tarkasteleminen

Projektin historia näkyy helposti Githubissa. Tarkastellaan historiaa ensin sitä kautta.

Navigoidessa projektin sivulle yläpalkissa on ensimmäisenä vasemmalla välilehti, josta pääsee tarkastelemaan committeja.

![Commitit GitHubissa](/assets/commits.png)

Kun välilehdettä painaa, näkee allekkain kaikki tehdyt commitit. Oikeassa reunassa näkyy kolme nappia.

![Commitin tarkasteleminen](/assets/browse-commit.png)

Napeista keskimmäisessä näkyy tietyn commitin id:n alkuosa. Kyseistä nappia painamalla on mahdollista nähdä kaikki commitissa tehdyt muutokset. Lisäykset näkyvät vihreällä, ja poistot punaisella.

![Muutosten tarkasteleminen](/assets/changes_in_github.jpeg)

Painamalla seuraavaksi "Browse files", tai edellisestä näkymästä oikeanpuolimmaista `<>`-painiketta, pääsee tarkastelemaan _koko projektia_ kyseisessä commitissa. Commit siis sisältää pelkästään muutokset, mutta Git mahdollistaa koko projektin tilan tarkastelemisen tietyn commitin jälkeen. Pääset palaamaan takaisin masteriin, eli päähaaran viimeisempään committiin painamalla painiketta vasemmalla, jossa lukee Tree, ja valitsemalla `master`.

![Miten vaihtaa takaisin masteriin](/assets/back-to-master.png)

Saman voi tehdä myös komentorivillä. Kun ollaan Git-projektin kansiossa, tiettyyn committiin voidaan siirtyä komennolla `git checkout commitin_id`. Tämä vastaa samaa, kuin GitHubissa koko projektin tilan tarkasteleminen tietyn commitin jälkeen. Samalla tavalla takaisin viimeisimpään committiin pääsee komennolla `git checkout haarannimi`, eli yleisimmässä tapauksessa `git checkout master`. Yksittäisen commitin muutoksia voidaan tarkastella komennolla `git show commitin_id`.

<div class="exercise">
<h3>Exercise 12: Salaisuus {% include points.html text="10%" %}</h3>
<ol>
<li>Luo projektiisi uusi tiedosto <code>salaisuus.txt</code>, ja kirjoita sisään esimerkiksi "tämä on hyvin salainen salaisuus".</li>
<li>Tee commit salaisuuden lisäämisestä.</li>
<li>Poista sen jälkeen tiedosto <code>salaisuus.txt</code>, ja tee poistosta uusi commit.</li>
<li>Puske muutoksesi GitHubiin.</li>
<li>Navigoi GitHubissa projektiisi. Etusivulla salaisuutta ei näy. Käy etsimässä salaisuus projektin historiasta. Etsi salaisuus sen jälkeen myös komentoriviltä.</li>
</ol>
</div>

<div class="warning">
Tämä on muistutus, että etärepositorioon ei pidä puskea mitään salaista: ei salasanoja, henkilökohtaisia API-avaimia, tai opiskelijanumeroa, tai muutakaan, mitä ei halua julkaista koko maailmalle.
</div>

## GitHubin workflow

GitHubin kaltaiset palvelut helpottavat merkittävästi yhteisten projektein kehittämistä. Käyttäjät huomaavat projektien ongelmat parhaiten. Projektille voi tehdä GitHubissa _issuen_, ja kertoa ohjelman vajaavaisuuksista. Jos tietää ongelman ratkaisun, voi sitä ehdottaa projektin omistajalle koodin muodossa.

GitHubissa sijaitsevan projektin voi kopioida kokonaisuudessaan omalle koneelleen komennolla `git clone`. Komento ottaa argumentiksi repositorion osoitteen, jonka saa projektikansion oikeasta yläkulmasta vihreästä napista. Kyseessä on siis sama osoite, joka annettiin aikaisemmin `git remote add`-komennolle argumentiksi. Projektin omistaja ei saa ilmoitusta siitä, että hänen projektinsa on kloonattu.

Jatkossa, kun aloitat uuden Git-projektin, voit joko luoda sen komentoriviltä komennolla `git init` ja lisätä sen jälkeen projektille etärepositorion, tai sitten voit ensin luoda GitHubissa repositorion, ja kloonata sen sitten koneellesi.

![Kloonausosoite](/assets/clone.png)

Jotta kloonaamaansa repositorioon tekemänsä muutokset voi puskea takaisin etärepositorioon, projektin omistajan tulee [lisätä kloonaaja projektin kehittäjäksi](https://help.github.com/articles/inviting-collaborators-to-a-personal-repository/). Muussa tapauksessa komento `git push` ei onnistu. Yhteisissä koodiprojekteissa voidaan siis luoda Git-projekti, jonka etärepositoriossa kaikki osallistujat ovat kehittäjinä, jolloin kaikki voivat vapaasti lisätä projektiin koodia.

On kuitenkin myös toinen tapa ehdottaa muutoksia olemassaolevaan projektiin: _fork_. Kun forkkaa projektin, kopio siitä lisätään käyttäjän omaksi repositorioksi hänen omaan profiiliiinsa. Tästä tulee ilmoitus GitHubin "feediin", ja projektin omistaja voi nähdä, kuka on forkannut projektin. Kun olet forkannut projektin, voit kloonata oman kopiosi koneellesi tavalliseen tapaan _omasta profiilistasi_, ja puskea muuutoksia _omaan kopioosi_.

Jos oman kopioosi tekemäsi muutokset ovat mielestäsi niin hyviä, että haluat ehdottaa niitä myös alkuperäiseen projektiin, sen voi tehdä [pull requestin](https://help.github.com/articles/about-pull-requests/) avulla. Tällöin alkuperäisen projektin omistaja voi halutessaan liittää mergen avulla muutoksesi projektiinsa.

<div class="exercise">
<h3>Exercise 13: Kloonaaminen {% include points.html text="10%" %}</h3>
<ol>
<li>Selvitä ensin Googlen avulla, miten saat selville komentoriviltä Git-projektin etärepositorioiden nimet ja osoitteet. Kyseessä on siis komento, joka ajetaan Git-projektin sisällä, kun sille on asetettu etärepositorio.</li>
<li>Etsi vapaavalintainen <a href="https://en.wikipedia.org/wiki/Open-source_software">vapaan lähdekoodin</a>-projekti GitHubista (esim. <a href="https://github.com/google/guava">Googlen Guava</a> tai <a href="https://github.com/orfjackal/varjocafe">VarjoCafe</a>). Kloonaa se ensin koneellesi. Selvitä sitten, minkä nimiseksi etärepositorio asetetaan automaattisesti kloonatessa. Voit tehdä tämän ajamalla edellisessä kohdassa selvittämäsi komennon kloonatun projektin sisällä.</li>
</ol>
</div>

<div class="exercise">
<h3>Exercise 14: Toisen projektin tutkiminen {% include points.html text="5%" %}</h3>
Tutki sen jälkeen jonkin vapaan lähdekoodin projektin repoa GitHubissa. Etsi, mistä löydät projektin issuet ja pull requestit. Etsi myös projektiin osallistuneet (<i>contributors</i>) ja heihin liittyvä statistiikka.
</div>

## Loppusanat

Vasta-alkajana yhteistyöprojekteissa versionhallinnan avulla hukkaa ja rikkoo helposti koodia - jos törmäät outoon virheeseen, kysy rohkeasti apua, äläkä ajele sokkona komentoja. Pitkälle pääsee pitämällä silmällä `git status`-komennon tulosteita, puskemalla varmuuskopioita ajoittain, ja kommunikoimalla muiden projektilaisten kanssa muuallakin kuin commit-viesteissä. Gittiä oppii parhaiten käyttämällä sitä, älä siis lannistu ja poista projektia heti epäonnistuessasi. Pahimmassa tapausessa voi aina kloonata projektin uudestaan, kunhan on muistanut siirtää työnsä GitHubiin.

On jälleen aika hengähtää ja pitää tauko. Anna mielesi levätä, ennen kuin palaat materiaaliin ja sen oppimistavoitteisiin.

Lisää Gitistä voi lukea esimerkiksi seuraavista lähteistä:

- <a href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a>
  - Pro Git Book on kohtuullisen raskas, mutta erittäin kattava dokumentaatio Gitistä. Kannattaa käyttää yksittäisen asian opiskelemiseen, kokonaan läpi rämpiminen voi olla turhan pitkäveteinen operaatio.
- <a href="http://ohshitgit.com/">http://ohshitgit.com/</a>
  - Apuja yleisiin ongelmatilanteisiin hauskasti puettuna.
  - Komennot sisältävät jonkin verran Gitin historian ylikirjoittamista, mitä emme tässä osassa käsitelleet, ja saattaa siten joskus viedä ojasta aallikkoon. Voi kuitenkin olla nopea apu epätoivon hetkinä, ja erityisesti ensimmäinen komento, `git reflog`, pelastaa tilanteissa, joissa on onnistunut sekoittamaan koko pakan.
- <a href="https://try.github.io/">https://try.github.io/</a>
  - GitHubin tutoriaali, joka alkaa ihan perusasioista. Käsittelee joitain asioita, joita ei käyty läpi tässä osassa, kuten `git diff` ja komentoriviltä haarojen yhdistäminen.
- Mikäli olet jo tutustunut Gittiin jonkin verran, saatat olla kiinnostunut oppimaan lisää Gitin historiasta. Historian säilyttäminen, jota demonstroitiin esimerkiksi salaisuus-Exercisessä, mahdollistaa myös sen muokkaamisen jälkikäteen. Vanhaa sanontaa mukaillen, _Voittajat kirjoittavat historian, ja mokailijat ylikirjoittavat Gitin historian_. Historian muokkaaminen on kuitenkin varsin vaarallista erityisesti yhteistyöprojekteissa, sillä sen avulla voi pilata muiden ihmisten koneilla olevia versioita. Jos olet kuitenkin edelleen kiinnostunut, Atlassanilla on erikseen tutoriaali [historian ylikirjoittamisesta](https://www.atlassian.com/git/tutorials/rewriting-history), sekä muita [edistyneempiä tutoriaaleja](https://www.atlassian.com/git/tutorials/advanced-overview).

P.S Mikäli olet läsnäoleva opiskelija yliopistossa, kannattaa käydä tarkistasssa GitHub student packin [tarjoukset](https://education.github.com/pack/offers), tarjolla on krediittejä esimerkiksi DigitalOcean ja AWS -palveluihin, sekä etuja myös itse Githubiin.
